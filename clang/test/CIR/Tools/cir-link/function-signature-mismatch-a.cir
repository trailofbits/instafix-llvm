// RUN: cir-link -sort-symbols -split-input-file %s | FileCheck %s

// Test that when two modules have the same function with different signatures,
// the linker's finalize() method reconciles cir.get_global types to match the
// linked function's actual type.
//
// This models the scenario where one translation unit declares:
//   extern int bar(int);
// and another defines:
//   char bar(char c) { return c; }

// The key verification is that cir.get_global's type is updated from
// !cir.ptr<!cir.func<(!s32i) -> !s32i>> to !cir.ptr<!cir.func<(!s8i) -> !s8i>>
// to match the linked function definition's actual type.

// CHECK:      cir.func @bar(%arg0: !s8i) -> !s8i {
// CHECK-NEXT:   cir.return %arg0 : !s8i
// CHECK-NEXT: }

// CHECK:      cir.func @caller() -> !s32i {
// CHECK-NEXT:   %[[ADDR:.*]] = cir.get_global @bar : !cir.ptr<!cir.func<(!s8i) -> !s8i>>
// CHECK-NEXT:   %[[ARG:.*]] = cir.const #cir.int<42> : !s32i
// CHECK-NEXT:   %[[RESULT:.*]] = cir.call %[[ADDR]](%[[ARG]]) : (!cir.ptr<!cir.func<(!s8i) -> !s8i>>, !s32i) -> !s32i
// CHECK-NEXT:   cir.return %[[RESULT]] : !s32i
// CHECK-NEXT: }

!s32i = !cir.int<s, 32>
!s8i = !cir.int<s, 8>

// Module 1: declares bar(int) -> int and calls it
module {
  cir.func private @bar(!s32i) -> !s32i

  cir.func @caller() -> !s32i {
    %0 = cir.get_global @bar : !cir.ptr<!cir.func<(!s32i) -> !s32i>>
    %1 = cir.const #cir.int<42> : !s32i
    %2 = cir.call %0(%1) : (!cir.ptr<!cir.func<(!s32i) -> !s32i>>, !s32i) -> !s32i
    cir.return %2 : !s32i
  }
}

// -----

!s8i = !cir.int<s, 8>

// Module 2: defines bar(char) -> char
module {
  cir.func @bar(%arg0: !s8i) -> !s8i {
    cir.return %arg0 : !s8i
  }
}
